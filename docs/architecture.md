# Architecture

OpenAgentShop generates Next.js applications that implement the Model Context Protocol (MCP) and Universal Commerce Protocol (UCP) for agentic commerce. This document explains the system architecture and design decisions.

## System Overview

```
                    ┌─────────────────────────┐
                    │     AI Agent / Host      │
                    │  (Claude, ChatGPT, etc.) │
                    └────────────┬────────────┘
                                 │ MCP (JSON-RPC)
                                 ▼
┌────────────────────────────────────────────────────────┐
│                  Generated Next.js App                  │
│                                                        │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐ │
│  │  MCP Server   │  │  MCP-UI      │  │  UCP         │ │
│  │  (tools)      │◄─│  (HTML       │  │  Checkout    │ │
│  │               │  │   renderer)  │  │  Manager     │ │
│  └──────┬───────┘  └──────────────┘  └──────┬───────┘ │
│         │                                     │        │
│         ▼                                     ▼        │
│  ┌──────────────────────────────────────────────────┐  │
│  │             PostgreSQL (Drizzle ORM)             │  │
│  │  products | product_media | orders | checkouts   │  │
│  └──────────────────────────────────────────────────┘  │
│                                                        │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐ │
│  │  Merchant     │  │  Commerce    │  │  UCP Profile │ │
│  │  Center UI    │  │  Feed API    │  │  Discovery   │ │
│  └──────────────┘  └──────────────┘  └──────────────┘ │
└────────────────────────────────────────────────────────┘
```

## Core Components

### 1. MCP Server (`/api/mcp`)

Implements MCP Streamable HTTP transport (spec 2025-11-25) using the official `@modelcontextprotocol/sdk`.

**Session model:** One MCP server instance per session. Sessions are created on `initialize` and destroyed on transport close.

**Tools are auto-generated** from the product catalog:
- Product discovery tools (`list_products`, `get_product`, `recommend_products`) are parameterized based on the catalog's custom attributes, tiers, and categories
- UCP checkout tools (`create_checkout`, `get_checkout`, `update_checkout`, `complete_checkout`, `cancel_checkout`) implement the full checkout lifecycle

### 2. MCP-UI Renderer

Generates HTML that MCP hosts render inline in the chat interface. Two delivery modes:

- **Classic mode:** HTML embedded directly in tool response `content[]` with `_meta.ui.resourceUri`
- **MCP Apps mode:** HTML registered as a resource, fetched via `resources/read`

Both modes are generated simultaneously for maximum host compatibility.

UI components are styled based on the catalog's branding configuration and custom attribute display settings.

### 3. UCP Checkout Session Manager

Implements `dev.ucp.shopping.checkout` capability (version 2026-01-11).

**Status lifecycle:**
```
incomplete ──► ready_for_complete ──► completed
     │
     └──► requires_escalation
     └──► canceled
```

- **Status evaluation** is declarative: buyer completeness (email, first_name, last_name) determines the transition from `incomplete` to `ready_for_complete`
- **Totals** are computed from line items with configurable tax rate
- **Line item resolution** looks up products by both numeric ID and catalog slug

### 4. Database Schema

Generated by the schema builder from the product catalog. Four core tables:

| Table | Purpose |
|-------|---------|
| `products` | Product catalog with custom attribute columns |
| `product_media` | Product images, videos, documents |
| `orders` | Completed order records |
| `checkout_sessions` | UCP checkout session state (JSONB) |

Custom attributes map to database columns:
- `string` → `text`
- `number` → `integer`
- `boolean` → `boolean`
- `string[]`, `number[]`, `json` → `jsonb`

### 5. Commerce Feed

Generates OpenAI-compatible JSONL product feed at `/api/feed`. Supports gzip compression and active-only filtering.

### 6. UCP Profile Discovery

Serves the UCP platform profile at `/.well-known/ucp`, advertising capabilities, services, and payment handlers for protocol-level discovery.

## Design Decisions

### Code Generation vs. Runtime Library

OpenAgentShop uses **code generation** rather than a runtime library approach. The SDK generates complete source files that are then part of your project. This was chosen because:

1. **Full visibility** - You can read, debug, and modify every line of generated code
2. **No runtime dependency** - The generated app has no dependency on the SDK at runtime
3. **Customization** - Generated code is the starting point; you can extend it freely
4. **Framework alignment** - Next.js apps work best with explicit file-based routing

### Minor-Unit Currency

All prices are stored and transmitted as integers in minor units (cents for USD). This follows UCP conventions and prevents floating-point arithmetic errors that are common in financial calculations.

### Session-Per-Connection MCP Architecture

Each MCP session gets its own server instance. This prevents cross-session state leakage and simplifies the programming model. The trade-off is memory usage, which is acceptable for typical workloads.

### JSONB for Custom Attributes

Array and object custom attributes are stored as JSONB columns rather than separate tables. This simplifies the schema and queries while still allowing PostgreSQL's JSONB operators for filtering.

## Data Flow

### Product Discovery

```
Agent calls list_products(tier="premium")
  └► MCP tool handler
      └► Drizzle query: SELECT * FROM products WHERE tier='premium'
          └► Format text summary + generate HTML
              └► Return content[] with text + HTML resource
                  └► Host renders text in chat, HTML in UI panel
```

### Checkout Flow

```
1. Agent calls create_checkout(line_items=[{item:{id:"1"}, quantity:1}])
   └► Resolve product IDs → validate → compute totals → evaluate status
       └► Store checkout_session in DB → return UCP JSON

2. Agent calls update_checkout(id, buyer:{email, first_name, last_name})
   └► Merge buyer data → re-evaluate status → ready_for_complete
       └► Update DB → return UCP JSON

3. Agent calls complete_checkout(id)
   └► Validate status=ready_for_complete → create order → mark completed
       └► Return UCP JSON with order metadata + confirmation UI
```

## Security Considerations

The generated app is configured for development by default:

- **CORS:** Permissive (`*`) - restrict in production
- **Authentication:** None - add your own auth middleware
- **Payment:** Mock handler - integrate a real payment provider
- **Session IDs:** Cryptographically secure UUIDs
- **Price integrity:** Minor-unit integers prevent precision errors

See the [UCP Integration](./ucp-integration.md) guide for production payment handler setup.
